/*
 * Simplified Jenkins CI/CD Pipeline for University Project
 * Author: Uttam Thakur
 * Course: CSY3056 - DevOps
 * University: University of Northampton
 */

pipeline {
    agent any
    
    environment {
        APP_NAME = 'task-management-system'
        DOCKER_IMAGE = 'task-management'
        CONTAINER_NAME = 'task-app-staging'
        CONTAINER_PORT = '8000'
        HOST_PORT = '8001'
    }
    
    options {
        buildDiscarder(logRotator(numToKeepStr: '5'))
        timeout(time: 15, unit: 'MINUTES')
        timestamps()
        skipDefaultCheckout(false)
        disableConcurrentBuilds()
    }
    
    stages {
        stage('Clean Workspace') {
            steps {
                cleanWs()
            }
        }
        
        stage('Checkout') {
            steps {
                echo "=== Checking out source code ==="
                checkout scm
                
                sh '''
                    echo "Files in workspace:"
                    ls -la
                    
                    # Verify required files exist
                    for file in app.py test_app.py requirements.txt Dockerfile; do
                        if [ -f "$file" ]; then
                            echo "‚úì Found: $file"
                        else
                            echo "‚úó Missing: $file"
                            exit 1
                        fi
                    done
                '''
            }
        }
        
        stage('Build Docker Image') {
            steps {
                echo "=== Building Docker image ==="
                sh '''
                    # Clean up old images first
                    echo "Cleaning up old images..."
                    docker images --format "{{.Repository}}:{{.Tag}}" | grep "^task-management:" | xargs -r docker rmi -f || true
                    docker images --format "{{.Repository}}:{{.Tag}}" | grep "localhost:5000/task-management:" | xargs -r docker rmi -f || true
                    
                    # Build the Docker image, ensuring no cache to pick up Dockerfile changes
                    docker build --no-cache -t ${DOCKER_IMAGE}:${BUILD_NUMBER} .
                    docker tag ${DOCKER_IMAGE}:${BUILD_NUMBER} ${DOCKER_IMAGE}:latest
                    
                    echo "Image built successfully:"
                    docker images | grep ${DOCKER_IMAGE}
                '''
            }
        }
        
        stage('Unit Tests') {
            steps {
                echo "=== Running unit tests ==="
                sh '''
                    echo "=== Debug Information ==="
                    echo "Current directory (host): $(pwd)"
                    echo "Host directory contents:"
                    ls -la
                    
                    echo "\\n=== Running tests with image ${DOCKER_IMAGE}:${BUILD_NUMBER} ==="
                    
                    # Force remove any existing test containers
                    docker ps -a --filter "name=unit-test-run" -q | xargs -r docker rm -f || true
                    
                    # Run the tests
                    docker run --rm \
                        --name unit-test-run \
                        --user root \
                        ${DOCKER_IMAGE}:${BUILD_NUMBER} \
                        bash -c '
                            cd /app
                            
                            echo "=== Container Environment ==="
                            echo "Working directory:"
                            pwd
                            echo "\\nDirectory contents:"
                            ls -la
                            
                            echo "\\nInstalling test dependencies..."
                            pip install -r requirements.txt
                            
                            echo "\\nPython version and location:"
                            which python3
                            python3 --version
                            
                            echo "\\nTest file contents:"
                            cat test_app.py
                            
                            echo "\\n=== Running Tests ==="
                            python3 -m unittest -v test_app.py
                        '
                '''
            }
        }
        
        stage('Deploy') {
            steps {
                echo "=== Deploying application ==="
                sh '''
                    echo "Cleaning up any existing containers and port conflicts..."
                    
                    # Stop and remove container by name
                    docker stop ${CONTAINER_NAME} || echo "No container named ${CONTAINER_NAME} to stop"
                    docker rm -f ${CONTAINER_NAME} || echo "No container named ${CONTAINER_NAME} to remove"
                    
                    # Find and stop any containers using our target port
                    echo "Checking for containers using port ${HOST_PORT}..."
                    EXISTING_CONTAINERS=$(docker ps --format "{{.Names}}" --filter "publish=${HOST_PORT}")
                    if [ ! -z "$EXISTING_CONTAINERS" ]; then
                        echo "Found containers using port ${HOST_PORT}: $EXISTING_CONTAINERS"
                        for container in $EXISTING_CONTAINERS; do
                            echo "Stopping container: $container"
                            docker stop $container || true
                            docker rm -f $container || true
                        done
                    else
                        echo "No containers found using port ${HOST_PORT}"
                    fi
                    
                    echo "Starting new container..."
                    # Run the new container with port mapping
                    docker run -d \
                        --name ${CONTAINER_NAME} \
                        -p ${HOST_PORT}:${CONTAINER_PORT} \
                        -e FLASK_ENV=staging \
                        -e PYTHONUNBUFFERED=1 \
                        ${DOCKER_IMAGE}:${BUILD_NUMBER}
                    
                    echo "Container started successfully:"
                    docker ps | grep ${CONTAINER_NAME}
                    
                    # Wait for container to start and show initial logs
                    sleep 5
                    echo "Initial container logs:"
                    docker logs ${CONTAINER_NAME}
                '''
            }
        }
        
        stage('Health Check') {
            steps {
                echo "=== Running health checks ==="
                sh '''
                    # Initial wait for app startup
                    echo "Waiting for app to start..."
                    sleep 10
                    
                    # Check container status
                    echo "Container status:"
                    docker ps -a | grep ${CONTAINER_NAME}
                    
                    # Show container logs
                    echo "Container logs:"
                    docker logs ${CONTAINER_NAME}
                    
                    # Perform health checks
                    for i in $(seq 1 5); do
                        echo "Attempt $i/5: Checking health endpoint..."
                        if docker exec ${CONTAINER_NAME} curl -f http://localhost:${CONTAINER_PORT}/health; then
                            echo "‚úì Health check passed!"
                            exit 0
                        else
                            echo "‚úó Health check attempt $i/5 failed"
                            echo "Container logs:"
                            docker logs ${CONTAINER_NAME} --tail 50
                            sleep 5
                        fi
                    done
                    
                    echo "‚ùå Health check failed after 5 attempts"
                    echo "Final container logs:"
                    docker logs ${CONTAINER_NAME}
                    exit 1
                '''
            }
        }
    }
    
    post {
        always {
            echo """
            === BUILD SUMMARY ===
            Build Number: ${BUILD_NUMBER}
            Image: ${DOCKER_IMAGE}:${BUILD_NUMBER}
            Container: ${CONTAINER_NAME}
            Access URL: http://localhost:${HOST_PORT}
            Health Check: http://localhost:${HOST_PORT}/health
            """
            
            sh '''
                # Clean up test containers and artifacts
                docker ps -a --filter "name=unit-test-run" -q | xargs -r docker rm -f || true
                docker ps -a | grep test | awk '{print $1}' | xargs -r docker rm -f || true
                docker image prune -f || true
                
                # Clean workspace
                rm -rf \
                    .coverage \
                    reports/ \
                    htmlcov/ \
                    .pytest_cache/ \
                    __pycache__/ \
                    .unittest \
                    2>/dev/null || true
            '''
        }
        
        success {
            echo """
            üéâ DEPLOYMENT SUCCESSFUL! üéâ
            
            Your application is running at: http://localhost:${HOST_PORT}
            Health check: http://localhost:${HOST_PORT}/health
            
            To test the API:
            curl http://localhost:${HOST_PORT}/tasks
            """
        }
        
        failure {
            echo """
            ‚ùå DEPLOYMENT FAILED ‚ùå
            
            Check the console output above for error details.
            Container logs: docker logs ${CONTAINER_NAME}
            """
            
            sh '''
                docker stop ${CONTAINER_NAME} || true
                docker rm -f ${CONTAINER_NAME} || true
            '''
        }
    }
} 