/*
 * Simplified Jenkins CI/CD Pipeline for University Project
 * Author: Uttam Thakur
 * Course: CSY3056 - DevOps
 * University: University of Northampton
 */

pipeline {
    agent any
    
    environment {
        APP_NAME = 'task-management-system'
        DOCKER_IMAGE = 'task-management'
        CONTAINER_NAME = 'task-app-staging'
        CONTAINER_PORT = '8000'
        HOST_PORT = '8001'
    }
    
    options {
        buildDiscarder(logRotator(numToKeepStr: '5'))
        timeout(time: 15, unit: 'MINUTES')
        timestamps()
    }
    
    stages {
        
        stage('Checkout Code') {
            steps {
                echo "=== Checking out source code ==="
                cleanWs()
                checkout scm
                
                // List files to verify checkout
                sh '''
                    echo "Files in workspace:"
                    ls -la
                    
                    # Verify required files exist
                    for file in app.py test_app.py requirements.txt Dockerfile; do
                        if [ -f "$file" ]; then
                            echo "‚úì Found: $file"
                        else
                            echo "‚úó Missing: $file"
                            exit 1
                        fi
                    done
                '''
            }
        }
        
        stage('Build Docker Image') {
            steps {
                echo "=== Building Docker image ==="
                sh '''
                    # Build the Docker image, ensuring no cache to pick up Dockerfile changes
                    docker build --no-cache -t ${DOCKER_IMAGE}:${BUILD_NUMBER} .
                    docker tag ${DOCKER_IMAGE}:${BUILD_NUMBER} ${DOCKER_IMAGE}:latest
                    
                    echo "Image built successfully:"
                    docker images | grep ${DOCKER_IMAGE}
                '''
            }
        }
        
        stage('Run Tests') {
            steps {
                sh '''
                    echo "=== Running unit tests ==="
                    # Run unit tests using the freshly built image
                    docker run --rm \
                        -v ${WORKSPACE}:/app \
                        -w /app \
                        ${DOCKER_IMAGE}:${BUILD_NUMBER} \
                        sh -c "python -m unittest discover -s . -p 'test*.py' -v"
                '''
            }
        }
        
        stage('Code Quality') {
            steps {
                echo "=== Running code quality checks ==="
                sh '''
                    # Basic code quality check
                    docker run --rm \
                        -v ${WORKSPACE}:/workspace \
                        -w /workspace \
                        ${DOCKER_IMAGE}:latest sh -c "
                        
                        # Install code quality tools
                        pip install flake8
                        
                        # Run flake8 for basic code quality
                        echo 'Running code quality check...'
                        flake8 app.py test_app.py --max-line-length=100 --statistics || true
                        
                        echo 'Code quality check completed!'
                    "
                '''
            }
        }
        
        stage('Deploy') {
            steps {
                echo "=== Deploying application ==="
                sh '''
                    echo "Cleaning up any existing containers and port conflicts..."
                    
                    # Stop and remove container by name
                    docker stop ${CONTAINER_NAME} || echo "No container named ${CONTAINER_NAME} to stop"
                    docker rm -f ${CONTAINER_NAME} || echo "No container named ${CONTAINER_NAME} to remove"
                    
                    # Find and stop any containers using our target port
                    echo "Checking for containers using port ${HOST_PORT}..."
                    EXISTING_CONTAINERS=$(docker ps --format "{{.Names}}" --filter "publish=${HOST_PORT}")
                    if [ ! -z "$EXISTING_CONTAINERS" ]; then
                        echo "Found containers using port ${HOST_PORT}: $EXISTING_CONTAINERS"
                        for container in $EXISTING_CONTAINERS; do
                            echo "Stopping container: $container"
                            docker stop $container || true
                            docker rm -f $container || true
                        done
                    else
                        echo "No containers found using port ${HOST_PORT}"
                    fi
                    
                    # Double-check: Kill any process using the port on host (if accessible)
                    echo "Checking if port ${HOST_PORT} is in use on host..."
                    netstat -tlnp | grep ":${HOST_PORT} " || echo "Port ${HOST_PORT} is free"
                    
                    # Wait a moment for cleanup
                    sleep 2
                    
                    echo "Starting new container..."
                    # Run the new container, mapping the host port so the app is reachable from outside the container
                    docker run -d \
                        --name ${CONTAINER_NAME} \
                        -p ${HOST_PORT}:${CONTAINER_PORT} \
                        -e FLASK_ENV=staging \
                        ${DOCKER_IMAGE}:${BUILD_NUMBER}
                    
                    echo "Container started successfully:"
                    docker ps | grep ${CONTAINER_NAME}
                    
                    echo "Port mapping:"
                    docker port ${CONTAINER_NAME}
                '''
            }
        }
        
        stage('Health Check') {
            steps {
                echo "Waiting for app to come up‚Ä¶"
                sleep 10
                sh '''
                for i in $(seq 1 5); do
                    if docker exec ${CONTAINER_NAME} curl -f http://localhost:${CONTAINER_PORT}/health; then
                    echo "‚úì Health check passed!"
                    exit 0
                    else
                    echo "‚úó health check attempt $i/5 failed"
                    sleep 5
                    fi
                done
                echo "‚ùå Health check failed after 5 attempts"
                docker logs ${CONTAINER_NAME} --tail 50
                exit 1
                '''
            }
        }
    }
    
    post {
        always {
            echo """
            === BUILD SUMMARY ===
            Build Number: ${BUILD_NUMBER}
            Image: ${DOCKER_IMAGE}:${BUILD_NUMBER}
            Container: ${CONTAINER_NAME}
            Access URL: http://localhost:${HOST_PORT}
            Health Check: http://localhost:${HOST_PORT}/health
            """
            
            // Clean up temporary files and test containers
            sh '''
                # Clean up any test containers
                docker ps -a | grep test | awk '{print $1}' | xargs -r docker rm -f || true
                # Remove dangling images
                docker image prune -f || true
            '''
        }
        
        success {
            echo """
            üéâ DEPLOYMENT SUCCESSFUL! üéâ
            
            Your application is running at: http://localhost:${HOST_PORT}
            Health check: http://localhost:${HOST_PORT}/health
            
            To test the API:
            curl http://localhost:${HOST_PORT}/tasks
            
            To stop the application:
            docker stop ${CONTAINER_NAME}
            """
        }
        
        failure {
            echo """
            ‚ùå DEPLOYMENT FAILED ‚ùå
            
            Check the console output above for error details.
            Container logs: docker logs ${CONTAINER_NAME}
            """
            
            // Clean up failed deployment
            sh '''
                docker stop ${CONTAINER_NAME} || true
                docker rm -f ${CONTAINER_NAME} || true
            '''
        }
    }
} 