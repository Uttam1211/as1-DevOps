/*
 * Simplified Jenkins CI/CD Pipeline for University Project
 * Author: Uttam Thakur
 * Course: CSY3056 - DevOps
 * University: University of Northampton
 */

pipeline {
    agent any
    
    environment {
        APP_NAME = 'task-management-system'
        DOCKER_IMAGE = 'task-management'
        CONTAINER_NAME = 'task-app-staging'
        CONTAINER_PORT = '8000'
        HOST_PORT = '8001'
    }
    
    options {
        buildDiscarder(logRotator(numToKeepStr: '5'))
        timeout(time: 15, unit: 'MINUTES')
        timestamps()
    }
    
    stages {
        
        stage('1. Checkout Code') {
            steps {
                echo "=== Checking out source code ==="
                cleanWs()
                checkout scm
                
                // List files to verify checkout
                sh '''
                    echo "Files in workspace:"
                    ls -la
                    
                    # Verify required files exist
                    for file in app.py test_app.py requirements.txt Dockerfile; do
                        if [ -f "$file" ]; then
                            echo "‚úì Found: $file"
                        else
                            echo "‚úó Missing: $file"
                            exit 1
                        fi
                    done
                '''
            }
        }
        
        stage('2. Build Docker Image') {
            steps {
                echo "=== Building Docker image ==="
                sh '''
                    # Build the Docker image, ensuring no cache to pick up Dockerfile changes
                    docker build --no-cache -t ${DOCKER_IMAGE}:${BUILD_NUMBER} .
                    docker tag ${DOCKER_IMAGE}:${BUILD_NUMBER} ${DOCKER_IMAGE}:latest
                    
                    echo "Image built successfully:"
                    docker images | grep ${DOCKER_IMAGE}
                '''
            }
        }
        
        stage('3. Run Tests') {
            steps {
                echo "=== Preparing to run automated tests ==="
                sh 'echo "JENKINS_AGENT_DEBUG: Current directory on agent is $(pwd)"'
                sh 'echo "JENKINS_AGENT_DEBUG: WORKSPACE variable is ${WORKSPACE}"'
                sh 'echo "JENKINS_AGENT_DEBUG: Listing contents of ${WORKSPACE} on agent:"'
                sh 'ls -la ${WORKSPACE} || echo "JENKINS_AGENT_DEBUG: Failed to list ${WORKSPACE}"'
                sh '''
                    if [ -f "${WORKSPACE}/test_app.py" ]; then
                        echo "JENKINS_AGENT_DEBUG: test_app.py FOUND in ${WORKSPACE} on agent"
                    else
                        echo "JENKINS_AGENT_DEBUG: test_app.py NOT FOUND in ${WORKSPACE} on agent - THIS IS LIKELY THE PROBLEM!"
                    fi
                    if [ -f "${WORKSPACE}/app.py" ]; then
                        echo "JENKINS_AGENT_DEBUG: app.py FOUND in ${WORKSPACE} on agent"
                    else
                        echo "JENKINS_AGENT_DEBUG: app.py NOT FOUND in ${WORKSPACE} on agent"
                    fi
                '''

                echo "=== Running automated tests inside Docker container ==="
                sh '''
                    # Create reports directory
                    mkdir -p reports/tests
                    
                    # Run tests using the Docker image
                    # Mount current directory and run tests directly
                    docker run --rm \
                        -v ${WORKSPACE}:/workspace \
                        -w /workspace \
                        ${DOCKER_IMAGE}:latest sh -c "
                        
                        # Show what files are available
                        echo 'Available files:'
                        ls -la
                        
                        # Install test dependencies
                        pip install coverage
                        
                        # Run the tests
                        echo 'Running unit tests...'
                        python -m unittest test_app.py -v
                        
                        # Run coverage analysis
                        echo 'Running coverage analysis...'
                        python -m coverage run --source=. test_app.py || echo "Coverage run failed"
                        python -m coverage report -m || echo "Coverage report failed"
                        
                        # Generate coverage HTML report
                        python -m coverage html -d reports/tests/coverage || echo "Coverage HTML generation failed"
                        
                        echo 'Tests completed!'
                    "
                '''
                
                // Archive test results
                archiveArtifacts artifacts: 'reports/tests/**', allowEmptyArchive: true
            }
        }
        
        stage('4. Code Quality Check') {
            steps {
                echo "=== Running code quality checks ==="
                sh '''
                    # Basic code quality check
                    docker run --rm \
                        -v ${WORKSPACE}:/workspace \
                        -w /workspace \
                        ${DOCKER_IMAGE}:latest sh -c "
                        
                        # Install code quality tools
                        pip install flake8
                        
                        # Run flake8 for basic code quality
                        echo 'Running code quality check...'
                        flake8 app.py test_app.py --max-line-length=100 --statistics || true
                        
                        echo 'Code quality check completed!'
                    "
                '''
            }
        }
        
        stage('5. Deploy Application') {
            steps {
                echo "=== Deploying application ==="
                sh '''
                    echo "Cleaning up any existing containers and port conflicts..."
                    
                    # Stop and remove container by name
                    docker stop ${CONTAINER_NAME} || echo "No container named ${CONTAINER_NAME} to stop"
                    docker rm -f ${CONTAINER_NAME} || echo "No container named ${CONTAINER_NAME} to remove"
                    
                    # Find and stop any containers using our target port
                    echo "Checking for containers using port ${HOST_PORT}..."
                    EXISTING_CONTAINERS=$(docker ps --format "{{.Names}}" --filter "publish=${HOST_PORT}")
                    if [ ! -z "$EXISTING_CONTAINERS" ]; then
                        echo "Found containers using port ${HOST_PORT}: $EXISTING_CONTAINERS"
                        for container in $EXISTING_CONTAINERS; do
                            echo "Stopping container: $container"
                            docker stop $container || true
                            docker rm -f $container || true
                        done
                    else
                        echo "No containers found using port ${HOST_PORT}"
                    fi
                    
                    # Double-check: Kill any process using the port on host (if accessible)
                    echo "Checking if port ${HOST_PORT} is in use on host..."
                    netstat -tlnp | grep ":${HOST_PORT} " || echo "Port ${HOST_PORT} is free"
                    
                    # Wait a moment for cleanup
                    sleep 2
                    
                    echo "Starting new container..."
                    # Run the new container
                    docker run -d \
                        --name ${CONTAINER_NAME} \
                        -p ${HOST_PORT}:${CONTAINER_PORT} \
                        -e FLASK_ENV=staging \
                        ${DOCKER_IMAGE}:${BUILD_NUMBER}
                    
                    echo "Container started successfully:"
                    docker ps | grep ${CONTAINER_NAME}
                    
                    echo "Port mapping:"
                    docker port ${CONTAINER_NAME}
                '''
            }
        }
        
        stage('6. Health Check') {
            steps {
                echo "=== Verifying application health ==="
                sh '''
                    # Wait for application to start
                    echo "Waiting for application to start..."
                    sleep 10
                    
                    # Check container status
                    echo "Container status:"
                    docker ps | grep ${CONTAINER_NAME}
                    
                    # Check container logs
                    echo "Container logs:"
                    docker logs ${CONTAINER_NAME} --tail 10
                    
                    # Check if port is accessible from host
                    echo "Testing connectivity on host port ${HOST_PORT}..."
                    
                    # Try health check multiple times
                    for i in 1 2 3 4 5; do
                        echo "Health check attempt $i/5..."
                        
                        # Check if we can reach the health endpoint
                        # Using host.docker.internal to reach the host from Jenkins container
                        if curl -f -s http://host.docker.internal:${HOST_PORT}/health; then
                            echo "‚úì Health check passed using host.docker.internal!"
                            
                            # Test API functionality
                            echo "Testing task creation..."
                            curl -X POST -H "Content-Type: application/json" \
                                -d '{"title":"Test Task","description":"Automated test"}' \
                                http://host.docker.internal:${HOST_PORT}/tasks
                            
                            echo "‚úì Application deployed successfully!"
                            exit 0
                        else
                            echo "‚úó Health check failed, attempt $i"
                            if [ $i -eq 5 ]; then
                                echo "Final attempt failed. Deployment unsuccessful."
                                echo "Final container status:"
                                docker ps -a | grep ${CONTAINER_NAME}
                                echo "Final container logs:"
                                docker logs ${CONTAINER_NAME}
                                echo "Port status:"
                                netstat -tlnp | grep ${HOST_PORT} || echo "Port not in use"
                                exit 1
                            fi
                            sleep 5
                        fi
                    done
                '''
            }
        }
    }
    
    post {
        always {
            echo """
            === BUILD SUMMARY ===
            Build Number: ${BUILD_NUMBER}
            Image: ${DOCKER_IMAGE}:${BUILD_NUMBER}
            Container: ${CONTAINER_NAME}
            Access URL: http://localhost:${HOST_PORT}
            Health Check: http://localhost:${HOST_PORT}/health
            """
            
            // Clean up temporary files and test containers
            sh '''
                # Clean up any test containers
                docker ps -a | grep test | awk '{print $1}' | xargs -r docker rm -f || true
                # Remove dangling images
                docker image prune -f || true
            '''
        }
        
        success {
            echo """
            üéâ DEPLOYMENT SUCCESSFUL! üéâ
            
            Your application is running at: http://localhost:${HOST_PORT}
            Health check: http://localhost:${HOST_PORT}/health
            
            To test the API:
            curl http://localhost:${HOST_PORT}/tasks
            
            To stop the application:
            docker stop ${CONTAINER_NAME}
            """
        }
        
        failure {
            echo """
            ‚ùå DEPLOYMENT FAILED ‚ùå
            
            Check the console output above for error details.
            Container logs: docker logs ${CONTAINER_NAME}
            """
            
            // Clean up failed deployment
            sh '''
                docker stop ${CONTAINER_NAME} || true
                docker rm -f ${CONTAINER_NAME} || true
            '''
        }
    }
} 