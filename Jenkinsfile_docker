/*
 * Jenkins CI/CD Pipeline for Task Management System - Staging Environment
 * 
 * Author: Uttam Thakur
 * Course: CSY3056 - Development Operations and Software Testing
 * University: University of Northampton
 * Academic Year: 2024-2025
 * Assignment: TASK 1 - CI/CD PIPELINE DESIGN AND SETUP
 * 
 * Pipeline Implementation:
 * - Docker containerization with multi-stage builds
 * - Automated testing with coverage reporting
 * - Security scanning and code quality analysis
 * - Container deployment and health monitoring
 * - Artifact archiving and reporting
 */

pipeline {
    agent any
    
    environment {
        // Application configuration
        APP_NAME = 'task-management-system'
        DOCKER_IMAGE = 'task-management'
        DOCKER_TAG = "${BUILD_NUMBER}"
        
        // Container configuration
        CONTAINER_NAME = 'task-management-staging'
        CONTAINER_PORT = '8000'
        HOST_PORT = '8001'
        
        // Network and registry
        DOCKER_NETWORK = 'task-management-network'
        DOCKER_REGISTRY = 'localhost:5000'
        
        // Git information (will be set after checkout)
        GIT_COMMIT = ''
        GIT_BRANCH = "${env.BRANCH_NAME ?: 'develop'}"
    }
    
    // Build triggers
    triggers {
        pollSCM('H/5 * * * *')
        githubPush()
    }
    
    // Pipeline options
    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timeout(time: 20, unit: 'MINUTES')
        timestamps()
        skipDefaultCheckout()
    }
    
    stages {
        
        stage('Checkout & Validation') {
            steps {
                // Clean workspace and checkout code
                cleanWs()
                checkout scm
                
                // Extract Git information after checkout
                script {
                    env.GIT_COMMIT = sh(returnStdout: true, script: 'git rev-parse --short HEAD').trim()
                    echo "Git Commit: ${env.GIT_COMMIT}"
                    echo "Git Branch: ${env.GIT_BRANCH}"
                }
                
                // Validate project structure
                sh '''
                    echo "Validating project structure..."
                    
                    # Check required files (POSIX shell compatible)
                    for file in Dockerfile app.py requirements.txt test_app.py; do
                        if [ ! -f "$file" ]; then
                            echo "Missing: $file"
                            exit 1
                        fi
                    done
                    
                    echo "Project structure validated"
                '''
            }
        }
        
        stage('Docker Environment Setup') {
            steps {
                // Verify Docker availability
                sh '''
                    docker --version
                    docker info >/dev/null 2>&1 || { echo "Docker daemon unavailable"; exit 1; }
                '''
                
                // Prepare Docker environment
                sh '''
                    # Create network if not exists
                    docker network ls | grep -q ${DOCKER_NETWORK} || docker network create ${DOCKER_NETWORK}
                    
                    # Clean up existing containers
                    docker rm -f ${CONTAINER_NAME} 2>/dev/null || true
                    
                    # Remove dangling images
                    docker image prune -f
                '''
            }
        }
        
        stage('Build Docker Images') {
            parallel {
                stage('Testing Image') {
                    steps {
                        sh '''
                            # Build image for testing with additional test dependencies
                            docker build \
                                -t ${DOCKER_IMAGE}:test-${DOCKER_TAG} \
                                -t ${DOCKER_IMAGE}:test-latest \
                                --build-arg BUILD_DATE=$(date -u +%Y-%m-%dT%H:%M:%SZ) \
                                --build-arg VCS_REF=${GIT_COMMIT} \
                                .
                            
                            # Install additional test dependencies in testing image
                            docker run --rm -v ${WORKSPACE}:/workspace -w /workspace \
                                ${DOCKER_IMAGE}:test-latest sh -c "
                                pip install coverage flake8 pylint bandit safety radon xmlrunner || true
                            " || echo "Test dependencies installation completed"
                        '''
                    }
                }
                stage('Production Image') {
                    steps {
                        sh '''
                            # Build production image
                            docker build \
                                -t ${DOCKER_IMAGE}:${DOCKER_TAG} \
                                -t ${DOCKER_IMAGE}:latest \
                                --build-arg BUILD_DATE=$(date -u +%Y-%m-%dT%H:%M:%SZ) \
                                --build-arg VCS_REF=${GIT_COMMIT} \
                                --build-arg BUILD_VERSION=${BUILD_NUMBER} \
                                .
                        '''
                    }
                }
            }
        }
        
        stage('Code Quality Analysis') {
            steps {
                // Create reports directory
                sh 'mkdir -p reports/quality'
                
                // Run code quality checks
                sh '''
                    docker run --rm \
                        -v ${WORKSPACE}:/workspace \
                        -w /workspace \
                        ${DOCKER_IMAGE}:test-latest sh -c "
                        flake8 app.py test_app.py --max-line-length=100 --statistics --format=html --htmldir=reports/quality/flake8 || true
                        pylint app.py --disable=missing-docstring,too-few-public-methods --output-format=json --reports=yes > reports/quality/pylint.json || true
                        radon cc app.py --show-complexity --average > reports/quality/complexity.txt || true
                    "
                '''
                
                // Archive quality reports
                archiveArtifacts artifacts: 'reports/quality/**', fingerprint: true, allowEmptyArchive: true
            }
        }
        
        stage('Automated Testing') {
            steps {
                // Create test reports directory
                sh 'mkdir -p reports/tests'
                
                // Run comprehensive test suite
                sh '''
                    docker run --rm \
                        -v ${WORKSPACE}:/workspace \
                        -w /workspace \
                        ${DOCKER_IMAGE}:test-latest sh -c "
                        python -m coverage run --source=. -m unittest discover -s . -p 'test_*.py' -v
                        python -m coverage report -m --skip-covered
                        python -m coverage html -d reports/tests/coverage_html
                        python -m coverage xml -o reports/tests/coverage.xml
                        python -m coverage json -o reports/tests/coverage.json
                    "
                '''
                
                // Archive test results
                archiveArtifacts artifacts: 'reports/tests/**', fingerprint: true, allowEmptyArchive: true
            }
        }
        
        stage('Security Scanning') {
            steps {
                // Create security reports directory
                sh 'mkdir -p reports/security'
                
                // Run security scans
                sh '''
                    docker run --rm \
                        -v ${WORKSPACE}:/workspace \
                        -w /workspace \
                        ${DOCKER_IMAGE}:test-latest sh -c "
                        safety check --json --output reports/security/safety.json || true
                        bandit -r app.py -f json -o reports/security/bandit.json || true
                        bandit -r app.py -f txt || true
                    "
                '''
                
                // Docker image security scan if trivy available
                sh '''
                    if command -v trivy >/dev/null 2>&1; then
                        trivy image --format json --output reports/security/trivy.json ${DOCKER_IMAGE}:${DOCKER_TAG} || true
                    fi
                '''
                
                // Archive security reports
                archiveArtifacts artifacts: 'reports/security/**', fingerprint: true, allowEmptyArchive: true
            }
        }
        
        stage('Container Registry') {
            steps {
                // Tag images for registry
                sh '''
                    docker tag ${DOCKER_IMAGE}:${DOCKER_TAG} ${DOCKER_REGISTRY}/${DOCKER_IMAGE}:staging-${DOCKER_TAG}
                    docker tag ${DOCKER_IMAGE}:latest ${DOCKER_REGISTRY}/${DOCKER_IMAGE}:staging-latest
                '''
                
                // Push to registry (configure authentication as needed)
                sh '''
                    echo "Registry push configured but disabled - configure authentication first"
                    # docker push ${DOCKER_REGISTRY}/${DOCKER_IMAGE}:staging-${DOCKER_TAG}
                    # docker push ${DOCKER_REGISTRY}/${DOCKER_IMAGE}:staging-latest
                '''
            }
        }
        
        stage('Deploy to Staging') {
            steps {
                // Deploy application container
                sh '''
                    docker run -d \
                        --name ${CONTAINER_NAME} \
                        --network ${DOCKER_NETWORK} \
                        -p ${HOST_PORT}:${CONTAINER_PORT} \
                        -e FLASK_ENV=staging \
                        -e PORT=${CONTAINER_PORT} \
                        -e BUILD_NUMBER=${BUILD_NUMBER} \
                        -e GIT_COMMIT=${GIT_COMMIT} \
                        --restart unless-stopped \
                        --label "environment=staging" \
                        --label "build=${BUILD_NUMBER}" \
                        --label "git.commit=${GIT_COMMIT}" \
                        ${DOCKER_IMAGE}:${DOCKER_TAG}
                '''
                
                // Wait for container startup
                sh 'sleep 15'
            }
        }
        
        stage('Health Verification') {
            steps {
                // Verify application health with retry logic
                sh '''
                    max_attempts=5
                    attempt=1
                    
                    while [ $attempt -le $max_attempts ]; do
                        if curl -s -f http://localhost:${HOST_PORT}/health; then
                            echo "Health check passed on attempt $attempt"
                            break
                        else
                            if [ $attempt -eq $max_attempts ]; then
                                echo "Health check failed after $max_attempts attempts"
                                docker logs ${CONTAINER_NAME} --tail 20
                                exit 1
                            fi
                            sleep 5
                            ((attempt++))
                        fi
                    done
                '''
                
                // Test API functionality
                sh '''
                    # Test task creation
                    curl -X POST -H "Content-Type: application/json" \
                        -d '{"title":"Staging Test Task","description":"Automated deployment test"}' \
                        http://localhost:${HOST_PORT}/tasks
                    
                    # Test task retrieval
                    curl -s http://localhost:${HOST_PORT}/tasks | head -c 200
                '''
            }
        }
        
        stage('Monitoring Setup') {
            steps {
                // Create monitoring scripts
                sh '''
                    mkdir -p monitoring
                    
                    # Health monitoring script
                    cat > monitoring/health_check.sh << 'EOF'
#!/bin/bash
# Health monitoring script for staging environment

APP_URL="http://localhost:${HOST_PORT}"
LOG_FILE="monitoring/health.log"

check_health() {
    if curl -s -f "$APP_URL/health" > /dev/null; then
        echo "$(date): Application healthy" >> $LOG_FILE
        return 0
    else
        echo "$(date): Application health check failed" >> $LOG_FILE
        return 1
    fi
}

check_container() {
    if docker ps | grep -q "${CONTAINER_NAME}"; then
        echo "$(date): Container running" >> $LOG_FILE
        return 0
    else
        echo "$(date): Container not running" >> $LOG_FILE
        return 1
    fi
}

# Generate status report
generate_report() {
    echo "=== STAGING HEALTH REPORT ===" > monitoring/status.txt
    echo "Generated: $(date)" >> monitoring/status.txt
    echo "Build: ${BUILD_NUMBER}" >> monitoring/status.txt
    echo "Commit: ${GIT_COMMIT}" >> monitoring/status.txt
    echo "" >> monitoring/status.txt
    docker ps | grep ${CONTAINER_NAME} >> monitoring/status.txt
    echo "" >> monitoring/status.txt
    docker stats ${CONTAINER_NAME} --no-stream >> monitoring/status.txt
    echo "" >> monitoring/status.txt
    docker logs ${CONTAINER_NAME} --tail 10 >> monitoring/status.txt
}

# Main check
if check_health && check_container; then
    echo "$(date): All systems operational" >> $LOG_FILE
    generate_report
    exit 0
else
    echo "$(date): Issues detected" >> $LOG_FILE
    generate_report
    exit 1
fi
EOF
                    
                    chmod +x monitoring/health_check.sh
                    ./monitoring/health_check.sh
                '''
                
                // Archive monitoring scripts
                archiveArtifacts artifacts: 'monitoring/**', fingerprint: true
            }
        }
    }
    
    post {
        always {
            // Generate build summary
            sh '''
                echo "=== BUILD SUMMARY ==="
                echo "Build: ${BUILD_NUMBER}"
                echo "Branch: ${GIT_BRANCH}"
                echo "Commit: ${GIT_COMMIT}"
                echo "Container: ${CONTAINER_NAME}"
                echo "Port: ${HOST_PORT}"
                echo "Image: ${DOCKER_IMAGE}:${DOCKER_TAG}"
            '''
            
            // Cleanup
            sh '''
                # Remove test containers
                docker ps -a | grep -E "(test|temp)" | awk '{print $1}' | xargs -r docker rm -f || true
                
                # Clean temporary files
                rm -rf .coverage .pytest_cache __pycache__ || true
                
                # Prune dangling images
                docker image prune -f || true
            '''
        }
        
        success {
            script {
                echo """
                DEPLOYMENT SUCCESSFUL
                
                Application URL: http://localhost:${HOST_PORT}
                Health Check: http://localhost:${HOST_PORT}/health
                
                Reports:
                - Coverage: ${BUILD_URL}artifact/reports/tests/coverage_html/index.html
                - Quality: ${BUILD_URL}artifact/reports/quality/
                - Security: ${BUILD_URL}artifact/reports/security/
                - Monitoring: ${BUILD_URL}artifact/monitoring/
                
                Container: ${DOCKER_IMAGE}:${DOCKER_TAG}
                Git: ${GIT_BRANCH}@${GIT_COMMIT}
                """
            }
        }
        
        failure {
            script {
                echo """
                DEPLOYMENT FAILED
                
                Build: ${BUILD_NUMBER}
                Git: ${GIT_BRANCH}@${GIT_COMMIT}
                Console: ${BUILD_URL}console
                Artifacts: ${BUILD_URL}artifact/
                """
                
                // Collect failure diagnostics
                sh '''
                    echo "=== FAILURE DIAGNOSTICS ==="
                    docker ps -a | grep task-management || echo "No containers found"
                    docker logs ${CONTAINER_NAME} --tail 20 || echo "No logs available"
                    docker images | grep ${DOCKER_IMAGE} || echo "No images found"
                    netstat -tlnp | grep ${HOST_PORT} || echo "Port not in use"
                '''
                
                // Cleanup failed deployment
                sh 'docker rm -f ${CONTAINER_NAME} || true'
            }
        }
        
        cleanup {
            echo "Pipeline cleanup completed"
        }
    }
} 