/*
 * University Jenkins Pipeline - CSY3056 DevOps
 * Simple, working pipeline for demonstration purposes
 * Author: Uttam Thakur
 */

pipeline {
    agent any
    
    environment {
        IMAGE_NAME = 'task-app'
        CONTAINER_NAME = 'uni-task-app'
        APP_PORT = '8080'  // Using different port to avoid conflicts
    }
    
    stages {
        
        stage('Checkout') {
            steps {
                echo "üì• Checking out code..."
                cleanWs()
                checkout scm
                sh 'ls -la'  // Show what files we have
            }
        }
        
        stage('Build') {
            steps {
                echo "üî® Building Docker image..."
                sh '''
                    docker build -t ${IMAGE_NAME}:${BUILD_NUMBER} .
                    docker tag ${IMAGE_NAME}:${BUILD_NUMBER} ${IMAGE_NAME}:latest
                '''
            }
        }
        
        stage('Test') {
            steps {
                echo "üß™ Running tests..."
                sh '''
                    # Run tests in a temporary container
                    docker run --rm \
                        -v ${WORKSPACE}:/workspace \
                        -w /workspace \
                        ${IMAGE_NAME}:latest \
                        python -m unittest test_app.py -v
                '''
            }
        }
        
        stage('Deploy') {
            steps {
                echo "üöÄ Deploying application..."
                sh '''
                    echo "üßπ Cleaning up any existing containers and port conflicts..."
                    
                    # Stop and remove container by name
                    docker stop ${CONTAINER_NAME} || echo "No container named ${CONTAINER_NAME} to stop"
                    docker rm -f ${CONTAINER_NAME} || echo "No container named ${CONTAINER_NAME} to remove"
                    
                    # Find and stop any containers using our target port (for host network mode)
                    echo "Checking for processes using port ${APP_PORT}..."
                    EXISTING_CONTAINERS=$(docker ps --format "{{.Names}}" | xargs -I {} docker port {} 2>/dev/null | grep ":${APP_PORT}" | cut -d: -f1 || true)
                    
                    # For host network mode, check for any containers that might conflict
                    echo "Stopping any containers that might use port ${APP_PORT}..."
                    docker ps --format "{{.Names}}" | grep -E "(task|app|uni)" | while read container; do
                        if [ "$container" != "${CONTAINER_NAME}" ]; then
                            echo "Stopping potential conflicting container: $container"
                            docker stop $container || true
                            docker rm -f $container || true
                        fi
                    done
                    
                    # Wait a moment for cleanup
                    sleep 3
                    
                    echo "üöÄ Starting new container with host networking..."
                    # Start new container with host networking to avoid issues
                    docker run -d \
                        --name ${CONTAINER_NAME} \
                        --network host \
                        -e PORT=${APP_PORT} \
                        ${IMAGE_NAME}:${BUILD_NUMBER}
                        
                    echo "‚úÖ Container started successfully!"
                    docker ps | grep ${CONTAINER_NAME}
                        
                    # Wait for startup
                    sleep 8
                '''
            }
        }
        
        stage('Verify') {
            steps {
                echo "‚úÖ Verifying deployment..."
                sh '''
                    # Check container is running
                    echo "üìä Container status:"
                    docker ps | grep ${CONTAINER_NAME}
                    
                    # Show container logs
                    echo "üìã Container logs:"
                    docker logs ${CONTAINER_NAME} --tail 10
                    
                    # Test health endpoint (with retry)
                    for i in 1 2 3; do
                        echo "üîç Health check attempt $i..."
                        if curl -f http://localhost:${APP_PORT}/health; then
                            echo "‚úÖ Application is healthy!"
                            break
                        else
                            echo "‚ùå Health check failed, retrying..."
                            sleep 3
                        fi
                        
                        if [ $i -eq 3 ]; then
                            echo "‚ùå All health checks failed"
                            echo "Final container logs:"
                            docker logs ${CONTAINER_NAME}
                            echo "Port status:"
                            netstat -tlnp | grep ${APP_PORT} || echo "Port ${APP_PORT} not in use"
                            exit 1
                        fi
                    done
                    
                    # Test API
                    echo "üß™ Testing API endpoints..."
                    curl -s http://localhost:${APP_PORT}/tasks | head -100
                '''
            }
        }
    }
    
    post {
        always {
            echo """
            üéì UNIVERSITY DEMO COMPLETE üéì
            
            Build: ${BUILD_NUMBER}
            Image: ${IMAGE_NAME}:${BUILD_NUMBER}
            Container: ${CONTAINER_NAME}
            App URL: http://localhost:${APP_PORT}
            """
        }
        
        success {
            echo """
            ‚úÖ SUCCESS! Application deployed and tested
            
            üåê Access your app: http://localhost:${APP_PORT}
            üîç Health check: http://localhost:${APP_PORT}/health
            üìã Tasks API: http://localhost:${APP_PORT}/tasks
            
            To stop: docker stop ${CONTAINER_NAME}
            """
        }
        
        failure {
            echo "‚ùå Pipeline failed. Check logs above."
            sh '''
                docker logs ${CONTAINER_NAME} || true
                docker stop ${CONTAINER_NAME} || true
                docker rm -f ${CONTAINER_NAME} || true
            '''
        }
    }
} 